{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst _require = require('stream'),\n      Readable = _require.Readable;\n\nconst sysPath = require('path');\n\nconst picomatch = require('picomatch');\n\nconst _require2 = require('util'),\n      promisify = _require2.promisify;\n\nconst _ref = [promisify(fs.readdir), promisify(fs.stat), promisify(fs.lstat)],\n      readdir = _ref[0],\n      stat = _ref[1],\n      lstat = _ref[2];\nconst supportsDirent = 'Dirent' in fs;\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst isWindows = process.platform === 'win32';\nconst supportsBigint = typeof BigInt === 'function';\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst STAT_OPTIONS_SUPPORT_LENGTH = 3;\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst FILE_TYPES = new Set([FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]);\nconst DIR_TYPES = new Set([DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]);\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = errorCode => NORMAL_FLOW_ERRORS.has(errorCode);\n\nconst checkBasename = f => f(entry.basename);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n\n    for (const item of filter) {\n      const trimmed = item.trim();\n\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      } else {\n        return entry => !negative.some(f => f(entry.basename));\n      }\n    } else {\n      return entry => positive.some(f => f(entry.basename));\n    }\n  }\n};\n\nclass ExploringDir {\n  constructor(path, depth) {\n    this.path = path;\n    this.depth = depth;\n  }\n\n}\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      fileFilter: path => true,\n      directoryFilter: path => true,\n      type: 'files',\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      highWaterMark: 1,\n      autoDestroy: true\n    });\n    const opts = Object.assign({}, ReaddirpStream.defaultOptions, options);\n    const root = opts.root;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    this._statMethod = opts.lstat ? lstat : stat;\n    this._statOpts = {\n      bigint: isWindows\n    };\n    this._maxDepth = opts.depth;\n    this._entryType = opts.type;\n    this._root = sysPath.resolve(root);\n    this._isDirent = !opts.alwaysStat && supportsDirent;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._readdir_options = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    }; // Launch stream with one parent, the root dir.\n\n    /** @type Array<[string, number]>  */\n\n    this.parents = [new ExploringDir(root, 0)];\n    this.filesToRead = 0;\n  }\n\n  async _read() {\n    do {\n      // If the stream was destroyed, we must not proceed.\n      if (this.destroyed) return;\n      const parent = this.parents.pop();\n\n      if (!parent) {\n        // ...we have files to process; but not directories.\n        // hence, parent is undefined; and we cannot execute fs.readdir().\n        // The files are being processed anywhere.\n        break;\n      }\n\n      await this._exploreDirectory(parent);\n    } while (!this.isPaused() && !this._isQueueEmpty());\n\n    this._endStreamIfQueueIsEmpty();\n  }\n\n  async _exploreDirectory(parent) {\n    /** @type Array<fs.Dirent|string> */\n    let files = []; // To prevent race conditions, we increase counter while awaiting readdir.\n\n    this.filesToRead++;\n\n    try {\n      files = await readdir(parent.path, this._readdir_options);\n    } catch (error) {\n      if (isNormalFlowError(error.code)) {\n        this._handleError(error);\n      } else {\n        this._handleFatalError(error);\n      }\n    }\n\n    this.filesToRead--; // If the stream was destroyed, after readdir is completed\n\n    if (this.destroyed) return;\n    this.filesToRead += files.length;\n    const entries = await Promise.all(files.map(dirent => this._formatEntry(dirent, parent)));\n    if (this.destroyed) return;\n\n    for (let i = 0; i < entries.length; i++) {\n      const entry = entries[i];\n      this.filesToRead--;\n\n      if (!entry) {\n        continue;\n      }\n\n      if (this._isDirAndMatchesFilter(entry)) {\n        this._pushNewParentIfLessThanMaxDepth(entry.fullPath, parent.depth + 1);\n\n        this._emitPushIfUserWantsDir(entry);\n      } else if (this._isFileAndMatchesFilter(entry)) {\n        this._emitPushIfUserWantsFile(entry);\n      }\n    }\n  }\n\n  _isStatOptionsSupported() {\n    return this._statMethod.length === STAT_OPTIONS_SUPPORT_LENGTH;\n  }\n\n  _stat(fullPath) {\n    if (isWindows && this._isStatOptionsSupported()) {\n      return this._statMethod(fullPath, this._statOpts);\n    } else {\n      return this._statMethod(fullPath);\n    }\n  }\n\n  async _formatEntry(dirent, parent) {\n    const basename = this._isDirent ? dirent.name : dirent;\n    const fullPath = sysPath.resolve(sysPath.join(parent.path, basename));\n    let stats;\n\n    if (this._isDirent) {\n      stats = dirent;\n    } else {\n      try {\n        stats = await this._stat(fullPath);\n      } catch (error) {\n        if (isNormalFlowError(error.code)) {\n          this._handleError(error);\n        } else {\n          this._handleFatalError(error);\n        }\n\n        return;\n      }\n    }\n\n    const path = sysPath.relative(this._root, fullPath);\n    /** @type {EntryInfo} */\n\n    const entry = {\n      path,\n      fullPath,\n      basename,\n      [this._statsProp]: stats\n    };\n    return entry;\n  }\n\n  _isQueueEmpty() {\n    return this.parents.length === 0 && this.filesToRead === 0 && this.readable;\n  }\n\n  _endStreamIfQueueIsEmpty() {\n    if (this._isQueueEmpty()) {\n      this.push(null);\n    }\n  }\n\n  _pushNewParentIfLessThanMaxDepth(parentPath, depth) {\n    if (depth <= this._maxDepth) {\n      this.parents.push(new ExploringDir(parentPath, depth));\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  _isDirAndMatchesFilter(entry) {\n    return entry[this._statsProp].isDirectory() && this._directoryFilter(entry);\n  }\n\n  _isFileAndMatchesFilter(entry) {\n    const stats = entry[this._statsProp];\n    const isFileType = this._entryType === EVERYTHING_TYPE && !stats.isDirectory() || stats.isFile() || stats.isSymbolicLink();\n    return isFileType && this._fileFilter(entry);\n  }\n\n  _emitPushIfUserWantsDir(entry) {\n    if (DIR_TYPES.has(this._entryType)) {\n      // TODO: Understand why this happens.\n      const fn = () => {\n        this.push(entry);\n      };\n\n      if (this._isDirent) setImmediate(fn);else fn();\n    }\n  }\n\n  _emitPushIfUserWantsFile(entry) {\n    if (FILE_TYPES.has(this._entryType)) {\n      this.push(entry);\n    }\n  }\n\n  _handleError(error) {\n    if (!this.destroyed) {\n      this.emit('warn', error);\n    }\n  }\n\n  _handleFatalError(error) {\n    this.destroy(error);\n  }\n\n}\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\n\n\nconst readdirp = (root, options = {}) => {\n  let type = options['entryType'] || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\n  if (type) options.type = type;\n\n  if (root == null || typeof root === 'undefined') {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new Error(`readdirp: root argument must be a string. Usage: readdirp(root, options)`);\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\nmodule.exports = readdirp;","map":{"version":3,"sources":["/Users/Nelson/Desktop/JITIOT/ServerAPI/node_modules/readdirp/index.js"],"names":["fs","require","Readable","sysPath","picomatch","promisify","readdir","stat","lstat","supportsDirent","isWindows","process","platform","supportsBigint","BigInt","BANG","NORMAL_FLOW_ERRORS","Set","STAT_OPTIONS_SUPPORT_LENGTH","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","FILE_TYPES","DIR_TYPES","ALL_TYPES","isNormalFlowError","errorCode","has","checkBasename","f","entry","basename","normalizeFilter","filter","undefined","glob","trim","Array","isArray","positive","negative","item","trimmed","charAt","push","slice","length","some","ExploringDir","constructor","path","depth","ReaddirpStream","defaultOptions","root","fileFilter","directoryFilter","type","alwaysStat","options","objectMode","highWaterMark","autoDestroy","opts","Object","assign","_fileFilter","_directoryFilter","_statMethod","_statOpts","bigint","_maxDepth","_entryType","_root","resolve","_isDirent","_statsProp","_readdir_options","encoding","withFileTypes","parents","filesToRead","_read","destroyed","parent","pop","_exploreDirectory","isPaused","_isQueueEmpty","_endStreamIfQueueIsEmpty","files","error","code","_handleError","_handleFatalError","entries","Promise","all","map","dirent","_formatEntry","i","_isDirAndMatchesFilter","_pushNewParentIfLessThanMaxDepth","fullPath","_emitPushIfUserWantsDir","_isFileAndMatchesFilter","_emitPushIfUserWantsFile","_isStatOptionsSupported","_stat","name","join","stats","relative","readable","parentPath","isDirectory","isFileType","isFile","isSymbolicLink","fn","setImmediate","emit","destroy","readdirp","Error","includes","readdirpPromise","reject","on","promise","default","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst { Readable } = require('stream');\nconst sysPath = require('path');\nconst picomatch = require('picomatch');\nconst { promisify } = require('util');\nconst [readdir, stat, lstat] = [promisify(fs.readdir), promisify(fs.stat), promisify(fs.lstat)];\nconst supportsDirent = 'Dirent' in fs;\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst isWindows = process.platform === 'win32';\nconst supportsBigint = typeof BigInt === 'function';\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst STAT_OPTIONS_SUPPORT_LENGTH = 3;\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst FILE_TYPES = new Set([FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]);\nconst DIR_TYPES = new Set([DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]);\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = errorCode => NORMAL_FLOW_ERRORS.has(errorCode);\n\nconst checkBasename = f => f(entry.basename);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      } else {\n        return entry => !negative.some(f => f(entry.basename));\n      }\n    } else {\n      return entry => positive.some(f => f(entry.basename));\n    }\n  }\n};\n\nclass ExploringDir {\n  constructor(path, depth) {\n    this.path = path;\n    this.depth = depth;\n  }\n}\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      fileFilter: path => true,\n      directoryFilter: path => true,\n      type: 'files',\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({ objectMode: true, highWaterMark: 1, autoDestroy: true });\n    const opts = Object.assign({}, ReaddirpStream.defaultOptions, options);\n    const { root } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    this._statMethod = opts.lstat ? lstat : stat;\n    this._statOpts = { bigint: isWindows };\n    this._maxDepth = opts.depth;\n    this._entryType = opts.type;\n    this._root = sysPath.resolve(root);\n    this._isDirent = !opts.alwaysStat && supportsDirent;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._readdir_options = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    /** @type Array<[string, number]>  */\n    this.parents = [new ExploringDir(root, 0)];\n    this.filesToRead = 0;\n  }\n\n  async _read() {\n    do {\n      // If the stream was destroyed, we must not proceed.\n      if (this.destroyed) return;\n\n      const parent = this.parents.pop();\n      if (!parent) {\n        // ...we have files to process; but not directories.\n        // hence, parent is undefined; and we cannot execute fs.readdir().\n        // The files are being processed anywhere.\n        break;\n      }\n      await this._exploreDirectory(parent);\n    } while (!this.isPaused() && !this._isQueueEmpty());\n\n    this._endStreamIfQueueIsEmpty();\n  }\n\n  async _exploreDirectory(parent) {\n    /** @type Array<fs.Dirent|string> */\n    let files = [];\n\n    // To prevent race conditions, we increase counter while awaiting readdir.\n    this.filesToRead++;\n    try {\n      files = await readdir(parent.path, this._readdir_options);\n    } catch (error) {\n      if (isNormalFlowError(error.code)) {\n        this._handleError(error);\n      } else {\n        this._handleFatalError(error);\n      }\n    }\n    this.filesToRead--;\n\n    // If the stream was destroyed, after readdir is completed\n    if (this.destroyed) return;\n\n    this.filesToRead += files.length;\n\n    const entries = await Promise.all(files.map(dirent => this._formatEntry(dirent, parent)));\n\n    if (this.destroyed) return;\n\n    for (let i = 0; i < entries.length; i++) {\n      const entry = entries[i];\n      this.filesToRead--;\n      if (!entry) {\n        continue;\n      }\n      if (this._isDirAndMatchesFilter(entry)) {\n        this._pushNewParentIfLessThanMaxDepth(entry.fullPath, parent.depth + 1);\n        this._emitPushIfUserWantsDir(entry);\n      } else if (this._isFileAndMatchesFilter(entry)) {\n        this._emitPushIfUserWantsFile(entry);\n      }\n    }\n  }\n\n  _isStatOptionsSupported() {\n    return this._statMethod.length === STAT_OPTIONS_SUPPORT_LENGTH;\n  }\n\n  _stat(fullPath) {\n    if (isWindows && this._isStatOptionsSupported()) {\n      return this._statMethod(fullPath, this._statOpts);\n    } else {\n      return this._statMethod(fullPath);\n    }\n  }\n\n  async _formatEntry(dirent, parent) {\n    const basename = this._isDirent ? dirent.name : dirent;\n    const fullPath = sysPath.resolve(sysPath.join(parent.path, basename));\n\n    let stats;\n    if (this._isDirent) {\n      stats = dirent;\n    } else {\n      try {\n        stats = await this._stat(fullPath);\n      } catch (error) {\n        if (isNormalFlowError(error.code)) {\n          this._handleError(error);\n        } else {\n          this._handleFatalError(error);\n        }\n        return;\n      }\n    }\n    const path = sysPath.relative(this._root, fullPath);\n\n    /** @type {EntryInfo} */\n    const entry = { path, fullPath, basename, [this._statsProp]: stats };\n\n    return entry;\n  }\n\n  _isQueueEmpty() {\n    return this.parents.length === 0 && this.filesToRead === 0 && this.readable;\n  }\n\n  _endStreamIfQueueIsEmpty() {\n    if (this._isQueueEmpty()) {\n      this.push(null);\n    }\n  }\n\n  _pushNewParentIfLessThanMaxDepth(parentPath, depth) {\n    if (depth <= this._maxDepth) {\n      this.parents.push(new ExploringDir(parentPath, depth));\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  _isDirAndMatchesFilter(entry) {\n    return entry[this._statsProp].isDirectory() && this._directoryFilter(entry);\n  }\n\n  _isFileAndMatchesFilter(entry) {\n    const stats = entry[this._statsProp];\n    const isFileType =\n      (this._entryType === EVERYTHING_TYPE && !stats.isDirectory()) ||\n      (stats.isFile() || stats.isSymbolicLink());\n    return isFileType && this._fileFilter(entry);\n  }\n\n  _emitPushIfUserWantsDir(entry) {\n    if (DIR_TYPES.has(this._entryType)) {\n      // TODO: Understand why this happens.\n      const fn = () => {\n        this.push(entry);\n      };\n      if (this._isDirent) setImmediate(fn);\n      else fn();\n    }\n  }\n\n  _emitPushIfUserWantsFile(entry) {\n    if (FILE_TYPES.has(this._entryType)) {\n      this.push(entry);\n    }\n  }\n\n  _handleError(error) {\n    if (!this.destroyed) {\n      this.emit('warn', error);\n    }\n  }\n\n  _handleFatalError(error) {\n    this.destroy(error);\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options['entryType'] || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (root == null || typeof root === 'undefined') {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new Error(`readdirp: root argument must be a string. Usage: readdirp(root, options)`);\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n"]},"metadata":{},"sourceType":"script"}