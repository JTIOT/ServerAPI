{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst scan = require('./scan');\n\nconst parse = require('./parse');\n\nconst utils = require('./utils');\n\nconst constants = require('./constants');\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    return str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n\n      return false;\n    };\n  }\n\n  if (typeof glob !== 'string' || glob === '') {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = picomatch.makeRe(glob, options, false, true);\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n\n  if (opts.ignore) {\n    const ignoreOpts = { ...options,\n      ignore: null,\n      onMatch: null,\n      onResult: null\n    };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const _picomatch$test = picomatch.test(input, regex, options, {\n      glob,\n      posix\n    }),\n          isMatch = _picomatch$test.isMatch,\n          match = _picomatch$test.match,\n          output = _picomatch$test.output;\n\n    const result = {\n      glob,\n      state,\n      regex,\n      posix,\n      input,\n      output,\n      match,\n      isMatch\n    };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\n\npicomatch.test = (input, regex, options, {\n  glob,\n  posix\n} = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return {\n      isMatch: false,\n      output: ''\n    };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = match && format ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return {\n    isMatch: !!match,\n    match,\n    output\n  };\n};\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(glob[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\n\npicomatch.parse = (glob, options) => parse(glob, options);\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * // { prefix: '!./',\n * //   input: '!./foo/*.js',\n * //   base: 'foo',\n * //   glob: '*.js',\n * //   negated: true,\n * //   isGlob: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\n\npicomatch.scan = (input, options) => scan(input, options);\n/**\n * Create a regular expression from a glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.makeRe(input[, options]);\n *\n * console.log(picomatch.makeRe('*.js'));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `input` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n  let state = {\n    negated: false,\n    fastpaths: true\n  };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = state.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse.fastpaths(input, options);\n  }\n\n  if (output === void 0) {\n    state = picomatch.parse(input, options);\n    state.prefix = prefix + (state.prefix || '');\n    output = state.output;\n  }\n\n  if (returnOutput === true) {\n    return output;\n  }\n\n  let source = `${prepend}(?:${output})${append}`;\n\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\n\npicomatch.constants = constants;\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;","map":{"version":3,"sources":["/Users/Nelson/Desktop/JITIOT/ServerAPI/node_modules/picomatch/lib/picomatch.js"],"names":["path","require","scan","parse","utils","constants","picomatch","glob","options","returnState","Array","isArray","fns","map","input","str","isMatch","state","TypeError","opts","posix","isWindows","regex","makeRe","isIgnored","ignore","ignoreOpts","onMatch","onResult","matcher","returnObject","test","match","output","result","onIgnore","format","toPosixSlashes","capture","matchBase","basename","exec","RegExp","patterns","returnOutput","prepend","contains","append","negated","fastpaths","prefix","startsWith","slice","source","toRegex","flags","nocase","err","debug","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    return str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n  }\n\n  if (typeof glob !== 'string' || glob === '') {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = picomatch.makeRe(glob, options, false, true);\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: !!match, match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(glob[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (glob, options) => parse(glob, options);\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * // { prefix: '!./',\n * //   input: '!./foo/*.js',\n * //   base: 'foo',\n * //   glob: '*.js',\n * //   negated: true,\n * //   isGlob: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Create a regular expression from a glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.makeRe(input[, options]);\n *\n * console.log(picomatch.makeRe('*.js'));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `input` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n  let state = { negated: false, fastpaths: true };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = state.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse.fastpaths(input, options);\n  }\n\n  if (output === void 0) {\n    state = picomatch.parse(input, options);\n    state.prefix = prefix + (state.prefix || '');\n    output = state.output;\n  }\n\n  if (returnOutput === true) {\n    return output;\n  }\n\n  let source = `${prepend}(?:${output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n"]},"metadata":{},"sourceType":"script"}