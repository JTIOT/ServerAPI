{"ast":null,"code":"'use strict';\n\nconst utils = require('./utils');\n\nconst _require = require('./constants'),\n      CHAR_ASTERISK = _require.CHAR_ASTERISK,\n      CHAR_AT = _require.CHAR_AT,\n      CHAR_BACKWARD_SLASH = _require.CHAR_BACKWARD_SLASH,\n      CHAR_COMMA = _require.CHAR_COMMA,\n      CHAR_DOT = _require.CHAR_DOT,\n      CHAR_EXCLAMATION_MARK = _require.CHAR_EXCLAMATION_MARK,\n      CHAR_FORWARD_SLASH = _require.CHAR_FORWARD_SLASH,\n      CHAR_LEFT_CURLY_BRACE = _require.CHAR_LEFT_CURLY_BRACE,\n      CHAR_LEFT_PARENTHESES = _require.CHAR_LEFT_PARENTHESES,\n      CHAR_LEFT_SQUARE_BRACKET = _require.CHAR_LEFT_SQUARE_BRACKET,\n      CHAR_PLUS = _require.CHAR_PLUS,\n      CHAR_QUESTION_MARK = _require.CHAR_QUESTION_MARK,\n      CHAR_RIGHT_CURLY_BRACE = _require.CHAR_RIGHT_CURLY_BRACE,\n      CHAR_RIGHT_PARENTHESES = _require.CHAR_RIGHT_PARENTHESES,\n      CHAR_RIGHT_SQUARE_BRACKET = _require.CHAR_RIGHT_SQUARE_BRACKET;\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\n\nmodule.exports = (input, options) => {\n  const opts = options || {};\n  const length = input.length - 1;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isGlob = false;\n  let backslashes = false;\n  let negated = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let braceEscaped = false;\n\n  const eos = () => index >= length;\n\n  const advance = () => {\n    prev = code;\n    return input.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = true;\n      next = advance();\n\n      if (next === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (!eos() && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          next = advance();\n          continue;\n        }\n\n        if (next === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (!braceEscaped && next === CHAR_DOT && (next = advance()) === CHAR_DOT) {\n          isGlob = true;\n          break;\n        }\n\n        if (!braceEscaped && next === CHAR_COMMA) {\n          isGlob = true;\n          break;\n        }\n\n        if (next === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            break;\n          }\n        }\n      }\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      if (prev === CHAR_DOT && index === start + 1) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (code === CHAR_ASTERISK) {\n      isGlob = true;\n      break;\n    }\n\n    if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {\n      isGlob = true;\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (!eos() && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          next = advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isGlob = true;\n          break;\n        }\n      }\n    }\n\n    const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_EXCLAMATION_MARK;\n\n    if (isExtglobChar && input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES) {\n      isGlob = true;\n      break;\n    }\n\n    if (!opts.nonegate && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      while (!eos() && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          code = advance();\n          continue;\n        }\n\n        if (code === CHAR_RIGHT_PARENTHESES) {\n          isGlob = true;\n          break;\n        }\n      }\n    }\n\n    if (isGlob) {\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isGlob = false;\n  }\n\n  let prefix = '';\n  const orig = input;\n  let base = input;\n  let glob = '';\n\n  if (start > 0) {\n    prefix = input.slice(0, start);\n    input = input.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = input.slice(0, lastIndex);\n    glob = input.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = input;\n  } else {\n    base = input;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== input) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  return {\n    prefix,\n    input: orig,\n    base,\n    glob,\n    negated,\n    isGlob\n  };\n};","map":{"version":3,"sources":["/Users/Nelson/Desktop/JITIOT/ServerAPI/node_modules/picomatch/lib/scan.js"],"names":["utils","require","CHAR_ASTERISK","CHAR_AT","CHAR_BACKWARD_SLASH","CHAR_COMMA","CHAR_DOT","CHAR_EXCLAMATION_MARK","CHAR_FORWARD_SLASH","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_PARENTHESES","CHAR_LEFT_SQUARE_BRACKET","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_PARENTHESES","CHAR_RIGHT_SQUARE_BRACKET","isPathSeparator","code","module","exports","input","options","opts","length","index","start","lastIndex","isGlob","backslashes","negated","braces","prev","braceEscaped","eos","advance","charCodeAt","next","isExtglobChar","nonegate","noparen","noext","prefix","orig","base","glob","slice","unescape","removeBackslashes"],"mappings":"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","sourcesContent":["'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nmodule.exports = (input, options) => {\n  const opts = options || {};\n  const length = input.length - 1;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isGlob = false;\n  let backslashes = false;\n  let negated = false;\n  let braces = 0;\n  let prev;\n  let code;\n\n  let braceEscaped = false;\n\n  const eos = () => index >= length;\n  const advance = () => {\n    prev = code;\n    return input.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = true;\n      next = advance();\n\n      if (next === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (!eos() && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          next = advance();\n          continue;\n        }\n\n        if (next === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (!braceEscaped && next === CHAR_DOT && (next = advance()) === CHAR_DOT) {\n          isGlob = true;\n          break;\n        }\n\n        if (!braceEscaped && next === CHAR_COMMA) {\n          isGlob = true;\n          break;\n        }\n\n        if (next === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n          if (braces === 0) {\n            braceEscaped = false;\n            break;\n          }\n        }\n      }\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (code === CHAR_ASTERISK) {\n      isGlob = true;\n      break;\n    }\n\n    if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {\n      isGlob = true;\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (!eos() && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          next = advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isGlob = true;\n          break;\n        }\n      }\n    }\n\n    const isExtglobChar = code === CHAR_PLUS\n      || code === CHAR_AT\n      || code === CHAR_EXCLAMATION_MARK;\n\n    if (isExtglobChar && input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES) {\n      isGlob = true;\n      break;\n    }\n\n    if (!opts.nonegate && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      while (!eos() && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          code = advance();\n          continue;\n        }\n\n        if (code === CHAR_RIGHT_PARENTHESES) {\n          isGlob = true;\n          break;\n        }\n      }\n    }\n\n    if (isGlob) {\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isGlob = false;\n  }\n\n  let prefix = '';\n  const orig = input;\n  let base = input;\n  let glob = '';\n\n  if (start > 0) {\n    prefix = input.slice(0, start);\n    input = input.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = input.slice(0, lastIndex);\n    glob = input.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = input;\n  } else {\n    base = input;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== input) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  return { prefix, input: orig, base, glob, negated, isGlob };\n};\n"]},"metadata":{},"sourceType":"script"}